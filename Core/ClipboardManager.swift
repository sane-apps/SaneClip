import AppKit
@preconcurrency import ApplicationServices
import Combine
import os.log
import SwiftUI
import UniformTypeIdentifiers
#if APP_STORE
    import UserNotifications
#endif
import WidgetKit

@MainActor
@Observable
// swiftlint:disable:next type_body_length
class ClipboardManager {
    static var shared: ClipboardManager!

    var history: [ClipboardItem] = []
    var pinnedItems: [ClipboardItem] = []
    var pasteStack: [ClipboardItem] = []
    var isPasteStackMode: Bool { !pasteStack.isEmpty }
    private var lastChangeCount: Int = 0
    /// Suppresses clipboard monitoring after we write to the pasteboard ourselves
    /// (e.g. paste-as-uppercase, smart paste, snippets) to prevent feedback loops
    /// where our own write gets captured as a new history entry.
    var isSelfWrite = false
    private var lastClipboardContent: String?
    private var lastCopyTime: Date?
    private var timer: Timer?
    private var maxHistorySize: Int { SettingsModel.shared.maxHistorySize }
    private let logger = Logger(subsystem: "com.saneclip.app", category: "ClipboardManager")

    // Security: Types to ignore — only ConcealedType (passwords/secrets) and
    // AutoGeneratedType (generated passwords). TransientType is intentionally NOT
    // included because many non-password apps set it alongside legitimate content
    // (e.g. browser image copies), and the ignoredBundleIDs check already catches
    // actual password managers.
    private let ignoredTypes: [NSPasteboard.PasteboardType] = [
        NSPasteboard.PasteboardType("org.nspasteboard.ConcealedType"),
        NSPasteboard.PasteboardType("org.nspasteboard.AutoGeneratedType")
    ]

    // Security: Bundle IDs to ignore (password managers)
    private let ignoredBundleIDs: Set<String> = [
        "com.agilebits.onepassword",
        "com.dashlane.dashlane",
        "com.lastpass.lastpass",
        "com.wsigenesis.1Password7"
    ]

    init() {
        lastChangeCount = NSPasteboard.general.changeCount
        startMonitoring()
        loadHistory()
    }

    private func startMonitoring() {
        timer = Timer.scheduledTimer(withTimeInterval: 0.25, repeats: true) { [weak self] _ in
            Task { @MainActor in
                self?.checkClipboard()
            }
        }
    }

    private func checkClipboard() {
        // Cleanup expired items periodically
        cleanupExpiredItems()

        let pasteboard = NSPasteboard.general
        guard pasteboard.changeCount != lastChangeCount else { return }
        lastChangeCount = pasteboard.changeCount

        // Skip if we just wrote to the pasteboard ourselves (paste-as-transform, snippets, etc.)
        if isSelfWrite {
            isSelfWrite = false
            return
        }

        // Security checks
        guard !containsTransientTypes(pasteboard) else { return }

        let frontmostApp = NSWorkspace.shared.frontmostApplication
        let sourceAppBundleID = frontmostApp?.bundleIdentifier
        let sourceAppName = frontmostApp?.localizedName

        guard !isExcludedApp(bundleID: sourceAppBundleID, name: sourceAppName) else { return }

        // Process content
        processClipboardContent(pasteboard, sourceAppBundleID: sourceAppBundleID, sourceAppName: sourceAppName)
    }

    private func containsTransientTypes(_ pasteboard: NSPasteboard) -> Bool {
        guard let types = pasteboard.types else { return false }

        // Log TransientType for monitoring (no longer blocked, but worth tracking)
        if types.contains(NSPasteboard.PasteboardType("org.nspasteboard.TransientType")) {
            let source = NSWorkspace.shared.frontmostApplication?.bundleIdentifier ?? "unknown"
            logger.debug("TransientType seen from \(source) (allowed through)")
        }

        for ignored in ignoredTypes where types.contains(ignored) {
            logger.debug("Ignored concealed/auto-generated clipboard content")
            return true
        }
        return false
    }

    private func cleanupExpiredItems() {
        let expireHours = SettingsModel.shared.autoExpireHours
        guard expireHours > 0 else { return }

        let cutoff = Date().addingTimeInterval(-Double(expireHours * 3600))
        let beforeCount = history.count

        // Remove expired items, but preserve pinned items
        history.removeAll { item in
            let shouldRemove = !isPinned(item) && item.timestamp < cutoff
            if shouldRemove, case .image = item.content {
                deleteThumbnail(id: item.id)
            }
            return shouldRemove
        }

        let afterCount = history.count
        if afterCount < beforeCount {
            saveHistory()
            logger.debug("Cleaned up \(beforeCount - afterCount) expired items")
        }
    }

    private func isExcludedApp(bundleID: String?, name: String?) -> Bool {
        guard let bundleID else { return false }

        if SettingsModel.shared.isAppExcluded(bundleID) {
            logger.debug("Skipping clipboard from excluded app: \(name ?? "unknown")")
            return true
        }

        if SettingsModel.shared.protectPasswords, ignoredBundleIDs.contains(bundleID) {
            logger.debug("Skipping clipboard from known password manager: \(bundleID)")
            return true
        }

        return false
    }

    /// Image file extensions for detecting image files copied from Finder
    private static let imageExtensions: Set<String> = [
        "png", "jpg", "jpeg", "gif", "bmp", "tiff", "tif", "webp", "heic", "heif", "ico", "svg"
    ]

    private func processClipboardContent(
        _ pasteboard: NSPasteboard, sourceAppBundleID: String?, sourceAppName: String?
    ) {
        // Check if this is a file copy from Finder — Finder puts the file ICON as TIFF
        // on the pasteboard, not the actual file content. Detect file URLs and load the
        // real image if it's an image file.
        if let fileURL = pasteboard.string(forType: .fileURL).flatMap({ URL(string: $0) }),
           fileURL.isFileURL,
           FileManager.default.fileExists(atPath: fileURL.path) {
            let ext = fileURL.pathExtension.lowercased()
            if Self.imageExtensions.contains(ext) {
                // Guard against very large files (>50MB) to avoid hanging
                let fileSize = (try? FileManager.default.attributesOfItem(atPath: fileURL.path)[.size] as? Int) ?? 0
                if fileSize > 50_000_000 {
                    logger.warning("Skipping large image file (\(fileSize / 1_000_000)MB): \(fileURL.lastPathComponent)")
                } else if let image = NSImage(contentsOf: fileURL) {
                    let size = image.size
                    logger.debug("Captured image file: \(fileURL.lastPathComponent) \(Int(size.width))×\(Int(size.height))")
                    lastClipboardContent = nil
                    lastCopyTime = nil
                    addItem(ClipboardItem(
                        content: .image(image),
                        sourceAppBundleID: sourceAppBundleID,
                        sourceAppName: sourceAppName
                    ))
                    return
                } else {
                    logger.warning("Failed to load image from file: \(fileURL.lastPathComponent)")
                }
                // Fall through to capture file path as text if image load failed
            }
            // Non-image file: fall through to capture file path as text
        }

        // Check for image data on pasteboard (e.g. "Copy Image" in browser)
        let hasImageType = pasteboard.types?.contains(where: {
            [.tiff, .png].contains($0)
        }) ?? false

        // Only use pasteboard image if there's no file URL (avoids capturing Finder icons)
        let hasFileURL = pasteboard.types?.contains(.fileURL) ?? false
        if hasImageType, !hasFileURL, let image = NSImage(pasteboard: pasteboard) {
            let size = image.size
            logger.debug("Captured image: \(Int(size.width))×\(Int(size.height))")
            lastClipboardContent = nil
            lastCopyTime = nil
            addItem(ClipboardItem(
                content: .image(image),
                sourceAppBundleID: sourceAppBundleID,
                sourceAppName: sourceAppName
            ))
        } else if let string = pasteboard.string(forType: .string), !string.isEmpty {
            let processedString = processString(string)
            lastClipboardContent = processedString
            lastCopyTime = Date()
            addItem(ClipboardItem(
                content: .text(processedString),
                sourceAppBundleID: sourceAppBundleID,
                sourceAppName: sourceAppName
            ))
        } else {
            lastClipboardContent = nil
            lastCopyTime = nil
        }
    }

    private func processString(_ string: String) -> String {
        let processed = ClipboardRulesManager.shared.process(string)
        if processed != string {
            logger.debug("Applied clipboard rules to content")
        }
        return processed
    }

    private func addItem(_ item: ClipboardItem) {
        // Don't add duplicates at the top
        if let first = history.first, first.contentHash == item.contentHash {
            return
        }

        // Remove existing duplicate if present
        history.removeAll { $0.contentHash == item.contentHash }

        // Add to front
        history.insert(item, at: 0)

        // Trim to max size, cleaning up thumbnails for removed items
        if history.count > maxHistorySize {
            let removed = history.suffix(from: maxHistorySize)
            for item in removed {
                if case .image = item.content {
                    deleteThumbnail(id: item.id)
                }
            }
            history = Array(history.prefix(maxHistorySize))
        }

        saveHistory()

        #if ENABLE_SYNC
            // Queue the new item for iCloud sync
            let shared = SharedClipboardItem(
                id: item.id,
                content: item.sharedContent,
                timestamp: item.timestamp,
                sourceAppBundleID: item.sourceAppBundleID,
                sourceAppName: item.sourceAppName,
                pasteCount: item.pasteCount,
                note: item.note
            )
            SyncCoordinator.shared.queueItemForSync(shared)
        #endif

        let currentCount = history.count
        logger.debug("Added clipboard item, history count: \(currentCount)")
    }

    func paste(item: ClipboardItem) {
        isSelfWrite = true
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()

        switch item.content {
        case let .text(string):
            pasteboard.setString(string, forType: .string)
        case let .image(image):
            if let tiffData = image.tiffRepresentation {
                pasteboard.setData(tiffData, forType: .tiff)
            }
        }

        // Move to front and increment paste count
        if let index = history.firstIndex(where: { $0.id == item.id }) {
            var updatedItem = history.remove(at: index)
            updatedItem.pasteCount += 1
            history.insert(updatedItem, at: 0)
            saveHistory()
        }

        SettingsModel.shared.pasteSound.play()
        dismissAndPaste()
    }

    /// Paste most recent item as plain text (for global shortcut)
    func pasteAsPlainText() {
        guard let item = history.first else { return }
        pasteAsPlainText(item: item)
    }

    /// Paste item as plain text (strips formatting)
    func pasteAsPlainText(item: ClipboardItem) {
        guard case let .text(string) = item.content else { return }

        isSelfWrite = true
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()
        pasteboard.setString(string, forType: .string)

        // Move to front and increment paste count
        if let index = history.firstIndex(where: { $0.id == item.id }) {
            var updatedItem = history.remove(at: index)
            updatedItem.pasteCount += 1
            history.insert(updatedItem, at: 0)
            saveHistory()
        }

        SettingsModel.shared.pasteSound.play()
        dismissAndPaste()
    }

    /// Smart paste: auto-selects paste behavior based on content type
    /// - Code → plain text (preserves indentation, strips rich formatting)
    /// - URL → cleaned URL with tracking params stripped
    /// - Everything else → standard paste
    func pasteSmartMode(item: ClipboardItem) {
        if item.isCode {
            pasteAsPlainText(item: item)
        } else if item.isURL, case let .text(urlString) = item.content {
            let cleaned = ClipboardItem.stripTrackingParams(from: urlString)
            isSelfWrite = true
            let pasteboard = NSPasteboard.general
            pasteboard.clearContents()
            pasteboard.setString(cleaned, forType: .string)

            if let index = history.firstIndex(where: { $0.id == item.id }) {
                var updatedItem = history.remove(at: index)
                updatedItem.pasteCount += 1
                history.insert(updatedItem, at: 0)
                saveHistory()
            }

            SettingsModel.shared.pasteSound.play()
            dismissAndPaste()
        } else {
            paste(item: item)
        }
    }

    /// Paste using the user's default paste mode preference
    func pasteWithDefaultMode(item: ClipboardItem) {
        switch SettingsModel.shared.defaultPasteMode {
        case .standard:
            paste(item: item)
        case .plain:
            pasteAsPlainText(item: item)
        case .smart:
            pasteSmartMode(item: item)
        }
    }

    /// Paste item with a text transformation applied
    func pasteWithTransform(item: ClipboardItem, transform: TextTransform) {
        guard case let .text(string) = item.content else { return }

        let transformed = transform.apply(to: string)
        isSelfWrite = true
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()
        pasteboard.setString(transformed, forType: .string)

        // Move to front and increment paste count
        if let index = history.firstIndex(where: { $0.id == item.id }) {
            var updatedItem = history.remove(at: index)
            updatedItem.pasteCount += 1
            history.insert(updatedItem, at: 0)
            saveHistory()
        }

        SettingsModel.shared.pasteSound.play()
        dismissAndPaste()
    }

    /// Paste an expanded snippet to the active application
    func pasteSnippet(_ snippet: Snippet, values: [String: String] = [:]) {
        let expanded = SnippetManager.shared.expand(snippet: snippet, values: values)

        isSelfWrite = true
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()
        pasteboard.setString(expanded, forType: .string)

        SnippetManager.shared.incrementUseCount(for: snippet)

        SettingsModel.shared.pasteSound.play()
        dismissAndPaste()
    }

    // MARK: - Paste Stack

    /// Add an item to the paste stack (FIFO queue)
    func addToPasteStack(_ item: ClipboardItem) {
        pasteStack.append(item)
        SettingsModel.shared.pasteSound.play()
    }

    /// Paste the next item from the stack (FIFO or LIFO based on settings)
    func pasteFromStack() {
        guard !pasteStack.isEmpty else { return }
        let item: ClipboardItem = if SettingsModel.shared.pasteStackReversed {
            pasteStack.removeLast()
        } else {
            pasteStack.removeFirst()
        }
        paste(item: item)
    }

    /// Clear all items from the paste stack
    func clearPasteStack() {
        pasteStack.removeAll()
    }

    /// Dismiss the popover (so Cmd+V targets the correct app) then simulate paste.
    private func dismissAndPaste() {
        NotificationCenter.default.post(name: .dismissForPaste, object: nil)
        #if APP_STORE
            showCopiedNotification()
        #else
            Task { @MainActor in
                try? await Task.sleep(for: .milliseconds(300))
                self.simulatePaste()
            }
        #endif
    }

    #if APP_STORE
        /// Show a brief "Copied to clipboard" notification for App Store builds
        /// where paste simulation (CGEvent) is not available in the sandbox.
        private func showCopiedNotification() {
            logger.debug("App Store mode: copied to clipboard, user must paste manually")
            // Request notification permission on first use, then deliver
            let center = UNUserNotificationCenter.current()
            center.requestAuthorization(options: [.alert, .sound]) { granted, _ in
                guard granted else { return }
                let content = UNMutableNotificationContent()
                content.title = "Copied to Clipboard"
                content.body = "Press \u{2318}V to paste"
                let request = UNNotificationRequest(
                    identifier: "com.saneclip.copied.\(UUID().uuidString)",
                    content: content,
                    trigger: nil
                )
                center.add(request)
            }
        }
    #else
        /// Whether accessibility permission alert is currently showing (prevents duplicates)
        private var isShowingPermissionAlert = false

        private func simulatePaste() {
            guard AXIsProcessTrusted() else {
                logger.error("Accessibility permission not granted — paste blocked")
                guard !isShowingPermissionAlert else { return }
                isShowingPermissionAlert = true
                // Dispatch to escape the async Task context — runModal() needs its own run loop
                DispatchQueue.main.async { [weak self] in
                    self?.showAccessibilityAlert()
                    self?.isShowingPermissionAlert = false
                }
                return
            }

            guard let source = CGEventSource(stateID: .hidSystemState) else {
                logger.error("Failed to create CGEventSource for paste simulation")
                return
            }

            guard let keyDown = CGEvent(keyboardEventSource: source, virtualKey: 0x09, keyDown: true),
                  let keyUp = CGEvent(keyboardEventSource: source, virtualKey: 0x09, keyDown: false)
            else {
                logger.error("Failed to create CGEvent for paste simulation")
                return
            }

            keyDown.flags = .maskCommand
            keyUp.flags = .maskCommand

            keyDown.post(tap: .cghidEventTap)
            keyUp.post(tap: .cghidEventTap)
        }

        /// Show a standalone NSAlert for accessibility permission — works even when the panel isn't visible
        /// (e.g., paste-as-plain-text, paste-from-stack, quick-paste hotkeys)
        private func showAccessibilityAlert() {
            let alert = NSAlert()
            alert.messageText = "Accessibility Permission Required"
            alert.informativeText = "SaneClip needs Accessibility permission to paste into other apps.\n\nGo to System Settings > Privacy & Security > Accessibility and enable SaneClip."
            alert.addButton(withTitle: "Open System Settings")
            alert.addButton(withTitle: "Cancel")
            alert.alertStyle = .warning

            if alert.runModal() == .alertFirstButtonReturn {
                if let url = URL(string: "x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility") {
                    NSWorkspace.shared.open(url)
                }
            }
        }
    #endif

    func delete(item: ClipboardItem) {
        // Clean up thumbnail file if this is an image item
        if case .image = item.content {
            deleteThumbnail(id: item.id)
        }

        history.removeAll { $0.id == item.id }
        pinnedItems.removeAll { $0.id == item.id }
        saveHistory()

        #if ENABLE_SYNC
            SyncCoordinator.shared.queueDeleteForSync(itemID: item.id)
        #endif
    }

    // MARK: - Sync Support

    #if ENABLE_SYNC
        /// Insert an item received from iCloud sync (no re-sync trigger)
        func insertSyncedItem(_ item: ClipboardItem) {
            // Don't add duplicates
            guard !history.contains(where: { $0.id == item.id }) else { return }
            history.insert(item, at: 0)

            // Trim to max size, cleaning up thumbnails for removed items
            if history.count > maxHistorySize {
                let removed = history.suffix(from: maxHistorySize)
                for removedItem in removed {
                    if case .image = removedItem.content {
                        deleteThumbnail(id: removedItem.id)
                    }
                }
                history = Array(history.prefix(maxHistorySize))
            }

            saveHistory()
            logger.debug("Inserted synced item: \(item.id)")
        }

        /// Delete an item received from iCloud sync (no re-sync trigger)
        func deleteSyncedItem(_ itemID: UUID) {
            // Clean up thumbnail if it's an image item
            if let item = history.first(where: { $0.id == itemID }),
               case .image = item.content {
                deleteThumbnail(id: itemID)
            }
            history.removeAll { $0.id == itemID }
            pinnedItems.removeAll { $0.id == itemID }
            saveHistory()
            logger.debug("Deleted synced item: \(itemID)")
        }
    #endif

    func clearHistory() {
        // Clean up all thumbnail files
        for item in history {
            if case .image = item.content {
                deleteThumbnail(id: item.id)
            }
        }
        history.removeAll()
        saveHistory()
    }

    func pasteItemAt(index: Int) {
        guard index < history.count else { return }
        paste(item: history[index])
    }

    func togglePin(item: ClipboardItem) {
        if pinnedItems.contains(where: { $0.id == item.id }) {
            pinnedItems.removeAll { $0.id == item.id }
        } else {
            pinnedItems.insert(item, at: 0)
        }
        saveHistory()
    }

    /// Copy item to clipboard without triggering paste (Cmd+V)
    func copyWithoutPaste(item: ClipboardItem) {
        isSelfWrite = true
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()

        switch item.content {
        case let .text(string):
            pasteboard.setString(string, forType: .string)
        case let .image(image):
            if let tiffData = image.tiffRepresentation {
                pasteboard.setData(tiffData, forType: .tiff)
            }
        }

        SettingsModel.shared.pasteSound.play()

        logger.debug("Copied item to clipboard (no paste)")
    }

    /// Update an item's text content (for edit functionality)
    func updateItemContent(id: UUID, newContent: String) {
        guard !newContent.isEmpty else { return }

        if let index = history.firstIndex(where: { $0.id == id }) {
            let existing = history[index]
            let updatedItem = ClipboardItem(
                id: existing.id,
                content: .text(newContent),
                timestamp: existing.timestamp,
                sourceAppBundleID: existing.sourceAppBundleID,
                sourceAppName: existing.sourceAppName,
                pasteCount: existing.pasteCount,
                note: existing.note
            )
            history[index] = updatedItem

            // Also update in pinnedItems if present
            if let pinnedIndex = pinnedItems.firstIndex(where: { $0.id == id }) {
                pinnedItems[pinnedIndex] = updatedItem
            }

            saveHistory()
            logger.debug("Updated content for item \(id)")
        }
    }

    /// Update an item's note
    func updateItemNote(id: UUID, note: String?) {
        let trimmedNote = note?.trimmingCharacters(in: .whitespacesAndNewlines)
        let finalNote = (trimmedNote?.isEmpty ?? true) ? nil : trimmedNote

        if let index = history.firstIndex(where: { $0.id == id }) {
            history[index].note = finalNote

            // Also update in pinnedItems if present
            if let pinnedIndex = pinnedItems.firstIndex(where: { $0.id == id }) {
                pinnedItems[pinnedIndex].note = finalNote
            }

            saveHistory()
            logger.debug("Updated note for item \(id)")
        }
    }

    func isPinned(_ item: ClipboardItem) -> Bool {
        pinnedItems.contains { $0.id == item.id }
    }

    /// Reorder pinned items via drag and drop
    func movePinnedItems(from source: IndexSet, to destination: Int) {
        pinnedItems.move(fromOffsets: source, toOffset: destination)
        saveHistory()
    }

    /// Export history to JSON data
    func exportHistory() -> Data? {
        let formatter = ISO8601DateFormatter()
        let pinnedIDs = Set(pinnedItems.map(\.id))
        let exportItems = history.compactMap { item -> [String: Any]? in
            var dict: [String: Any] = [
                "id": item.id.uuidString,
                "timestamp": formatter.string(from: item.timestamp),
                "pasteCount": item.pasteCount
            ]

            if case let .text(string) = item.content {
                dict["text"] = string
            } else {
                // Skip images in export
                return nil
            }

            if let bundleID = item.sourceAppBundleID {
                dict["sourceAppBundleID"] = bundleID
            }
            if let appName = item.sourceAppName {
                dict["sourceAppName"] = appName
            }

            dict["isPinned"] = pinnedIDs.contains(item.id)

            return dict
        }

        return try? JSONSerialization.data(withJSONObject: exportItems, options: .prettyPrinted)
    }

    /// Static export function for use from Settings (reads from disk)
    nonisolated static func exportHistoryFromDisk() -> Data? {
        let appSupport = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
        let historyURL = appSupport
            .appendingPathComponent("SaneClip", isDirectory: true)
            .appendingPathComponent("history.json")

        guard FileManager.default.fileExists(atPath: historyURL.path),
              var data = try? Data(contentsOf: historyURL)
        else {
            return nil
        }

        // Auto-detect encrypted vs plaintext
        if HistoryEncryption.isEncrypted(data) {
            guard let decrypted = try? HistoryEncryption.decrypt(data) else { return nil }
            data = decrypted
        }

        guard let items = try? JSONDecoder().decode([SavedClipboardItem].self, from: data) else {
            return nil
        }

        let pinnedIDs = Set(UserDefaults.standard.stringArray(forKey: "pinnedItemIDs") ?? [])
        let formatter = ISO8601DateFormatter()

        let exportItems: [[String: Any]] = items.map { item in
            var dict: [String: Any] = [
                "id": item.id.uuidString,
                "timestamp": formatter.string(from: item.timestamp),
                "text": item.text,
                "pasteCount": item.pasteCount,
                "isPinned": pinnedIDs.contains(item.id.uuidString)
            ]
            if let bundleID = item.sourceAppBundleID {
                dict["sourceAppBundleID"] = bundleID
            }
            if let appName = item.sourceAppName {
                dict["sourceAppName"] = appName
            }
            return dict
        }

        return try? JSONSerialization.data(withJSONObject: exportItems, options: .prettyPrinted)
    }

    // MARK: - Persistence

    private var historyFileURL: URL {
        let appSupport = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
        let appFolder = appSupport.appendingPathComponent("SaneClip", isDirectory: true)
        try? FileManager.default.createDirectory(at: appFolder, withIntermediateDirectories: true)
        return appFolder.appendingPathComponent("history.json")
    }

    private var thumbnailsDirectory: URL {
        let appSupport = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
        let dir = appSupport
            .appendingPathComponent("SaneClip", isDirectory: true)
            .appendingPathComponent("thumbnails", isDirectory: true)
        try? FileManager.default.createDirectory(at: dir, withIntermediateDirectories: true)
        return dir
    }

    /// Save a downsized thumbnail for an image item, returns the filename
    private func saveThumbnail(image: NSImage, id: UUID) -> String? {
        let maxDimension: CGFloat = 200
        let size = image.size

        // Calculate downsized dimensions preserving aspect ratio
        let scale: CGFloat = if size.width > maxDimension || size.height > maxDimension {
            min(maxDimension / size.width, maxDimension / size.height)
        } else {
            1.0
        }
        let newSize = NSSize(width: size.width * scale, height: size.height * scale)

        // Draw downsized image
        let resized = NSImage(size: newSize)
        resized.lockFocus()
        image.draw(in: NSRect(origin: .zero, size: newSize),
                   from: NSRect(origin: .zero, size: size),
                   operation: .copy,
                   fraction: 1.0)
        resized.unlockFocus()

        // Save as JPEG
        guard let tiffData = resized.tiffRepresentation,
              let bitmap = NSBitmapImageRep(data: tiffData),
              let jpegData = bitmap.representation(using: .jpeg, properties: [.compressionFactor: 0.7])
        else {
            logger.warning("Failed to create thumbnail JPEG for item \(id)")
            return nil
        }

        let filename = "\(id.uuidString).jpg"
        let fileURL = thumbnailsDirectory.appendingPathComponent(filename)
        do {
            try jpegData.write(to: fileURL, options: .atomic)
            return filename
        } catch {
            logger.warning("Failed to write thumbnail: \(error.localizedDescription)")
            return nil
        }
    }

    /// Delete the thumbnail file for a given item ID
    private func deleteThumbnail(id: UUID) {
        let fileURL = thumbnailsDirectory.appendingPathComponent("\(id.uuidString).jpg")
        try? FileManager.default.removeItem(at: fileURL)
    }

    /// Load a thumbnail image from disk
    private func loadThumbnail(filename: String) -> NSImage? {
        let fileURL = thumbnailsDirectory.appendingPathComponent(filename)
        return NSImage(contentsOf: fileURL)
    }

    func saveHistory() {
        // Save text items directly; save image items as downsized thumbnails on disk
        let savedItems = history.compactMap { item -> SavedClipboardItem? in
            switch item.content {
            case let .text(string):
                return SavedClipboardItem(
                    id: item.id,
                    text: string,
                    timestamp: item.timestamp,
                    sourceAppBundleID: item.sourceAppBundleID,
                    sourceAppName: item.sourceAppName,
                    pasteCount: item.pasteCount,
                    note: item.note
                )
            case let .image(image):
                // Save thumbnail to disk; skip if save fails
                guard let filename = saveThumbnail(image: image, id: item.id) else { return nil }
                return SavedClipboardItem(
                    id: item.id,
                    text: "[Image]",
                    timestamp: item.timestamp,
                    sourceAppBundleID: item.sourceAppBundleID,
                    sourceAppName: item.sourceAppName,
                    pasteCount: item.pasteCount,
                    note: item.note,
                    imageThumbnailFilename: filename
                )
            }
        }

        do {
            var data = try JSONEncoder().encode(savedItems)

            // Encrypt if setting is enabled
            if SettingsModel.shared.encryptHistory {
                data = try HistoryEncryption.encrypt(data)
            }

            try data.write(to: historyFileURL, options: [.atomic, .completeFileProtection])

            // Save pinned item IDs separately
            let pinnedIDs = pinnedItems.map(\.id.uuidString)
            UserDefaults.standard.set(pinnedIDs, forKey: "pinnedItemIDs")

            // Update widget data
            updateWidgetData()
        } catch {
            logger.error("Failed to save history: \(error.localizedDescription)")
        }
    }

    // MARK: - Widget Support

    /// Updates widget data in the shared App Group container
    private func updateWidgetData() {
        // Convert history items to widget format
        let recentWidgetItems = history.prefix(10).map { item in
            WidgetClipboardItem(
                id: item.id,
                preview: item.preview,
                timestamp: item.timestamp,
                isPinned: isPinned(item),
                sourceAppName: item.sourceAppName,
                contentType: widgetContentType(for: item)
            )
        }

        // Convert pinned items to widget format
        let pinnedWidgetItems = pinnedItems.map { item in
            WidgetClipboardItem(
                id: item.id,
                preview: item.preview,
                timestamp: item.timestamp,
                isPinned: true,
                sourceAppName: item.sourceAppName,
                contentType: widgetContentType(for: item)
            )
        }

        let container = WidgetDataContainer(
            recentItems: Array(recentWidgetItems),
            pinnedItems: pinnedWidgetItems,
            lastUpdated: Date()
        )

        do {
            try container.save()
            // Tell WidgetKit to reload
            WidgetCenter.shared.reloadAllTimelines()
            logger.debug("Updated widget data with \(recentWidgetItems.count) recent, \(pinnedWidgetItems.count) pinned items")
        } catch {
            logger.warning("Failed to update widget data: \(error.localizedDescription)")
        }
    }

    private func widgetContentType(for item: ClipboardItem) -> WidgetClipboardItem.ContentType {
        switch item.content {
        case .text:
            if item.isURL { return .url }
            if item.isCode { return .code }
            return .text
        case .image:
            return .image
        }
    }

    private func loadHistory() {
        guard FileManager.default.fileExists(atPath: historyFileURL.path) else { return }

        do {
            var data = try Data(contentsOf: historyFileURL)

            // Auto-detect encrypted vs plaintext for seamless migration
            if HistoryEncryption.isEncrypted(data) {
                data = try HistoryEncryption.decrypt(data)
            }

            let items = try JSONDecoder().decode([SavedClipboardItem].self, from: data)
            history = items.compactMap { saved -> ClipboardItem? in
                let note = saved.note?.isEmpty == true ? nil : saved.note

                // Image item: load thumbnail from disk
                if let thumbnailFilename = saved.imageThumbnailFilename,
                   let image = loadThumbnail(filename: thumbnailFilename) {
                    return ClipboardItem(
                        id: saved.id,
                        content: .image(image),
                        timestamp: saved.timestamp,
                        sourceAppBundleID: saved.sourceAppBundleID,
                        sourceAppName: saved.sourceAppName,
                        pasteCount: saved.pasteCount,
                        note: note
                    )
                }

                // Skip image items whose thumbnail is missing (file deleted externally)
                if saved.imageThumbnailFilename != nil {
                    logger.warning("Thumbnail missing for item \(saved.id), skipping")
                    return nil
                }

                // Text item
                return ClipboardItem(
                    id: saved.id,
                    content: .text(saved.text),
                    timestamp: saved.timestamp,
                    sourceAppBundleID: saved.sourceAppBundleID,
                    sourceAppName: saved.sourceAppName,
                    pasteCount: saved.pasteCount,
                    note: note
                )
            }

            // Restore pinned items from saved IDs
            if let pinnedIDs = UserDefaults.standard.stringArray(forKey: "pinnedItemIDs") {
                let pinnedUUIDs = Set(pinnedIDs.compactMap { UUID(uuidString: $0) })
                pinnedItems = history.filter { pinnedUUIDs.contains($0.id) }
            }
        } catch {
            logger.error("Failed to load history: \(error.localizedDescription)")
        }
    }

    // MARK: - Import History

    enum ImportError: Error, LocalizedError {
        case invalidFormat
        case readFailed
        case decodeFailed

        var errorDescription: String? {
            switch self {
            case .invalidFormat: "Invalid file format"
            case .readFailed: "Could not read file"
            case .decodeFailed: "Could not decode history data"
            }
        }
    }

    /// Import history from a JSON file
    /// - Parameters:
    ///   - url: URL to the JSON file
    ///   - merge: If true, merge with existing history; if false, replace entirely
    /// - Returns: Number of items imported
    @discardableResult
    func importHistory(from url: URL, merge: Bool) throws -> Int {
        // Read file
        guard let data = try? Data(contentsOf: url) else {
            throw ImportError.readFailed
        }

        // Try to decode as SavedClipboardItem array
        guard let items = try? JSONDecoder().decode([SavedClipboardItem].self, from: data) else {
            throw ImportError.decodeFailed
        }

        // Convert to ClipboardItems
        let importedItems = items.map { saved in
            ClipboardItem(
                id: saved.id,
                content: .text(saved.text),
                timestamp: saved.timestamp,
                sourceAppBundleID: saved.sourceAppBundleID,
                sourceAppName: saved.sourceAppName,
                pasteCount: saved.pasteCount,
                note: saved.note?.isEmpty == true ? nil : saved.note
            )
        }

        if merge {
            // Skip items with existing IDs
            let existingIDs = Set(history.map(\.id))
            let newItems = importedItems.filter { !existingIDs.contains($0.id) }
            history.append(contentsOf: newItems)
            // Sort by timestamp, newest first
            history.sort { $0.timestamp > $1.timestamp }
            saveHistory()
            logger.info("Merged \(newItems.count) new items from import")
            return newItems.count
        } else {
            // Replace entire history
            history = importedItems
            pinnedItems = [] // Clear pins since items are new
            saveHistory()
            logger.info("Replaced history with \(importedItems.count) imported items")
            return importedItems.count
        }
    }

    // MARK: - Services Support

    /// Add an item from macOS Services (public wrapper for private addItem)
    func addItemFromService(_ item: ClipboardItem) {
        addItem(item)
    }

    // MARK: - PDF Export

    func exportItemAsPDF(item: ClipboardItem) {
        guard case let .text(text) = item.content else { return }

        let savePanel = NSSavePanel()
        savePanel.allowedContentTypes = [.pdf]
        let firstLine = text.components(separatedBy: .newlines).first ?? "clipboard"
        let cleanName = String(
            firstLine.prefix(50)
                .replacingOccurrences(of: "[^a-zA-Z0-9 _\\-]", with: "", options: .regularExpression)
                .trimmingCharacters(in: .whitespaces)
        )
        savePanel.nameFieldStringValue = (cleanName.isEmpty ? "clipboard" : cleanName) + ".pdf"

        guard savePanel.runModal() == .OK, let url = savePanel.url else { return }

        // PDF dimensions: US Letter
        let pageWidth: CGFloat = 612
        let pageHeight: CGFloat = 792
        let margin: CGFloat = 72
        let textRect = CGRect(x: margin, y: margin, width: pageWidth - 2 * margin, height: pageHeight - 2 * margin)

        let font = CTFontCreateWithName("Menlo" as CFString, 11, nil)
        let paragraphStyle = NSMutableParagraphStyle()
        paragraphStyle.lineSpacing = 4
        let attributes: [NSAttributedString.Key: Any] = [
            .font: font,
            .foregroundColor: NSColor.black,
            .paragraphStyle: paragraphStyle
        ]
        let attributedString = NSAttributedString(string: text, attributes: attributes)
        let framesetter = CTFramesetterCreateWithAttributedString(attributedString)

        var mediaBox = CGRect(x: 0, y: 0, width: pageWidth, height: pageHeight)
        guard let dataConsumer = CGDataConsumer(url: url as CFURL),
              let pdfContext = CGContext(consumer: dataConsumer, mediaBox: &mediaBox, nil)
        else {
            logger.error("Failed to create PDF context")
            return
        }

        var currentIndex = 0
        while currentIndex < attributedString.length {
            pdfContext.beginPDFPage(nil)

            let path = CGPath(rect: textRect, transform: nil)
            let frameRange = CFRange(location: currentIndex, length: 0)
            let frame = CTFramesetterCreateFrame(framesetter, frameRange, path, nil)

            CTFrameDraw(frame, pdfContext)

            let visibleRange = CTFrameGetVisibleStringRange(frame)
            currentIndex += visibleRange.length

            pdfContext.endPDFPage()

            // Safety: break if no progress
            if visibleRange.length == 0 { break }
        }

        pdfContext.closePDF()
        logger.info("Exported clipboard item as PDF to \(url.path)")
    }
}
