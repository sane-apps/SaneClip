import AppKit
@preconcurrency import ApplicationServices
import Combine
import os.log
import SwiftUI
import UniformTypeIdentifiers
import WidgetKit

@MainActor
@Observable
// swiftlint:disable:next type_body_length
class ClipboardManager {
    static var shared: ClipboardManager!

    var history: [ClipboardItem] = []
    var pinnedItems: [ClipboardItem] = []
    var pasteStack: [ClipboardItem] = []
    var isPasteStackMode: Bool { !pasteStack.isEmpty }
    private var lastChangeCount: Int = 0
    private var lastClipboardContent: String?
    private var lastCopyTime: Date?
    private var timer: Timer?
    private var maxHistorySize: Int { SettingsModel.shared.maxHistorySize }
    private let logger = Logger(subsystem: "com.saneclip.app", category: "ClipboardManager")

    // Security: Types to ignore
    private let ignoredTypes: [NSPasteboard.PasteboardType] = [
        NSPasteboard.PasteboardType("org.nspasteboard.TransientType"),
        NSPasteboard.PasteboardType("org.nspasteboard.ConcealedType"),
        NSPasteboard.PasteboardType("org.nspasteboard.AutoGeneratedType")
    ]

    // Security: Bundle IDs to ignore (password managers)
    private let ignoredBundleIDs: Set<String> = [
        "com.agilebits.onepassword",
        "com.dashlane.dashlane",
        "com.lastpass.lastpass",
        "com.wsigenesis.1Password7"
    ]

    init() {
        lastChangeCount = NSPasteboard.general.changeCount
        startMonitoring()
        loadHistory()
    }

    private func startMonitoring() {
        timer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true) { [weak self] _ in
            Task { @MainActor in
                self?.checkClipboard()
            }
        }
    }

    private func checkClipboard() {
        // Cleanup expired items periodically
        cleanupExpiredItems()

        let pasteboard = NSPasteboard.general
        guard pasteboard.changeCount != lastChangeCount else { return }
        lastChangeCount = pasteboard.changeCount

        // Security checks
        guard !containsTransientTypes(pasteboard) else { return }

        let frontmostApp = NSWorkspace.shared.frontmostApplication
        let sourceAppBundleID = frontmostApp?.bundleIdentifier
        let sourceAppName = frontmostApp?.localizedName

        guard !isExcludedApp(bundleID: sourceAppBundleID, name: sourceAppName) else { return }

        // Process content
        processClipboardContent(pasteboard, sourceAppBundleID: sourceAppBundleID, sourceAppName: sourceAppName)
    }

    private func containsTransientTypes(_ pasteboard: NSPasteboard) -> Bool {
        guard let types = pasteboard.types else { return false }
        for ignored in ignoredTypes where types.contains(ignored) {
            logger.debug("Ignored transient/concealed clipboard content")
            return true
        }
        return false
    }

    private func cleanupExpiredItems() {
        let expireHours = SettingsModel.shared.autoExpireHours
        guard expireHours > 0 else { return }

        let cutoff = Date().addingTimeInterval(-Double(expireHours * 3600))
        let beforeCount = history.count

        // Remove expired items, but preserve pinned items
        history.removeAll { item in
            !isPinned(item) && item.timestamp < cutoff
        }

        let afterCount = history.count
        if afterCount < beforeCount {
            saveHistory()
            logger.debug("Cleaned up \(beforeCount - afterCount) expired items")
        }
    }

    private func isExcludedApp(bundleID: String?, name: String?) -> Bool {
        guard let bundleID else { return false }

        if SettingsModel.shared.isAppExcluded(bundleID) {
            logger.debug("Skipping clipboard from excluded app: \(name ?? "unknown")")
            return true
        }

        if SettingsModel.shared.protectPasswords, ignoredBundleIDs.contains(bundleID) {
            logger.debug("Skipping clipboard from known password manager: \(bundleID)")
            return true
        }

        return false
    }

    private func processClipboardContent(
        _ pasteboard: NSPasteboard, sourceAppBundleID: String?, sourceAppName: String?
    ) {
        if let string = pasteboard.string(forType: .string), !string.isEmpty {
            let processedString = processString(string)
            lastClipboardContent = processedString
            lastCopyTime = Date()
            addItem(ClipboardItem(
                content: .text(processedString),
                sourceAppBundleID: sourceAppBundleID,
                sourceAppName: sourceAppName
            ))
        } else if let image = NSImage(pasteboard: pasteboard) {
            lastClipboardContent = nil
            lastCopyTime = nil
            addItem(ClipboardItem(
                content: .image(image),
                sourceAppBundleID: sourceAppBundleID,
                sourceAppName: sourceAppName
            ))
        } else {
            lastClipboardContent = nil
            lastCopyTime = nil
        }
    }

    private func processString(_ string: String) -> String {
        let processed = ClipboardRulesManager.shared.process(string)
        if processed != string {
            logger.debug("Applied clipboard rules to content")
        }
        return processed
    }

    private func addItem(_ item: ClipboardItem) {
        // Don't add duplicates at the top
        if let first = history.first, first.contentHash == item.contentHash {
            return
        }

        // Remove existing duplicate if present
        history.removeAll { $0.contentHash == item.contentHash }

        // Add to front
        history.insert(item, at: 0)

        // Trim to max size
        if history.count > maxHistorySize {
            history = Array(history.prefix(maxHistorySize))
        }

        saveHistory()

        #if ENABLE_SYNC
            // Queue the new item for iCloud sync
            let shared = SharedClipboardItem(
                id: item.id,
                content: item.sharedContent,
                timestamp: item.timestamp,
                sourceAppBundleID: item.sourceAppBundleID,
                sourceAppName: item.sourceAppName,
                pasteCount: item.pasteCount
            )
            SyncCoordinator.shared.queueItemForSync(shared)
        #endif

        let currentCount = history.count
        logger.debug("Added clipboard item, history count: \(currentCount)")
    }

    func paste(item: ClipboardItem) {
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()

        switch item.content {
        case let .text(string):
            pasteboard.setString(string, forType: .string)
        case let .image(image):
            if let tiffData = image.tiffRepresentation {
                pasteboard.setData(tiffData, forType: .tiff)
            }
        }

        // Move to front and increment paste count
        if let index = history.firstIndex(where: { $0.id == item.id }) {
            var updatedItem = history.remove(at: index)
            updatedItem.pasteCount += 1
            history.insert(updatedItem, at: 0)
            saveHistory()
        }

        // Play a subtle sound (if enabled)
        if SettingsModel.shared.playSounds {
            NSSound(named: .init("Pop"))?.play()
        }

        // Simulate Cmd+V with longer delay to let popover close
        Task { @MainActor in
            try? await Task.sleep(for: .milliseconds(200))
            self.simulatePaste()
        }
    }

    /// Paste most recent item as plain text (for global shortcut)
    func pasteAsPlainText() {
        guard let item = history.first else { return }
        pasteAsPlainText(item: item)
    }

    /// Paste item as plain text (strips formatting)
    func pasteAsPlainText(item: ClipboardItem) {
        guard case let .text(string) = item.content else { return }

        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()
        pasteboard.setString(string, forType: .string)

        // Move to front and increment paste count
        if let index = history.firstIndex(where: { $0.id == item.id }) {
            var updatedItem = history.remove(at: index)
            updatedItem.pasteCount += 1
            history.insert(updatedItem, at: 0)
            saveHistory()
        }

        if SettingsModel.shared.playSounds {
            NSSound(named: .init("Pop"))?.play()
        }

        Task { @MainActor in
            try? await Task.sleep(for: .milliseconds(200))
            self.simulatePaste()
        }
    }

    /// Smart paste: auto-selects paste behavior based on content type
    /// - Code → plain text (preserves indentation, strips rich formatting)
    /// - URL → cleaned URL with tracking params stripped
    /// - Everything else → standard paste
    func pasteSmartMode(item: ClipboardItem) {
        if item.isCode {
            pasteAsPlainText(item: item)
        } else if item.isURL, case let .text(urlString) = item.content {
            let cleaned = ClipboardItem.stripTrackingParams(from: urlString)
            let pasteboard = NSPasteboard.general
            pasteboard.clearContents()
            pasteboard.setString(cleaned, forType: .string)

            if let index = history.firstIndex(where: { $0.id == item.id }) {
                var updatedItem = history.remove(at: index)
                updatedItem.pasteCount += 1
                history.insert(updatedItem, at: 0)
                saveHistory()
            }

            if SettingsModel.shared.playSounds {
                NSSound(named: .init("Pop"))?.play()
            }

            Task { @MainActor in
                try? await Task.sleep(for: .milliseconds(200))
                self.simulatePaste()
            }
        } else {
            paste(item: item)
        }
    }

    /// Paste using the user's default paste mode preference
    func pasteWithDefaultMode(item: ClipboardItem) {
        switch SettingsModel.shared.defaultPasteMode {
        case .standard:
            paste(item: item)
        case .plain:
            pasteAsPlainText(item: item)
        case .smart:
            pasteSmartMode(item: item)
        }
    }

    /// Paste item with a text transformation applied
    func pasteWithTransform(item: ClipboardItem, transform: TextTransform) {
        guard case let .text(string) = item.content else { return }

        let transformed = transform.apply(to: string)
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()
        pasteboard.setString(transformed, forType: .string)

        // Move to front and increment paste count
        if let index = history.firstIndex(where: { $0.id == item.id }) {
            var updatedItem = history.remove(at: index)
            updatedItem.pasteCount += 1
            history.insert(updatedItem, at: 0)
            saveHistory()
        }

        if SettingsModel.shared.playSounds {
            NSSound(named: .init("Pop"))?.play()
        }

        Task { @MainActor in
            try? await Task.sleep(for: .milliseconds(200))
            self.simulatePaste()
        }
    }

    /// Paste an expanded snippet to the active application
    func pasteSnippet(_ snippet: Snippet, values: [String: String] = [:]) {
        let expanded = SnippetManager.shared.expand(snippet: snippet, values: values)

        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()
        pasteboard.setString(expanded, forType: .string)

        SnippetManager.shared.incrementUseCount(for: snippet)

        if SettingsModel.shared.playSounds {
            NSSound(named: .init("Pop"))?.play()
        }

        Task { @MainActor in
            try? await Task.sleep(for: .milliseconds(200))
            self.simulatePaste()
        }
    }

    // MARK: - Paste Stack

    /// Add an item to the paste stack (FIFO queue)
    func addToPasteStack(_ item: ClipboardItem) {
        pasteStack.append(item)
        if SettingsModel.shared.playSounds {
            NSSound(named: .init("Pop"))?.play()
        }
    }

    /// Paste the next item from the stack (FIFO or LIFO based on settings)
    func pasteFromStack() {
        guard !pasteStack.isEmpty else { return }
        let item: ClipboardItem = if SettingsModel.shared.pasteStackReversed {
            pasteStack.removeLast()
        } else {
            pasteStack.removeFirst()
        }
        paste(item: item)
    }

    /// Clear all items from the paste stack
    func clearPasteStack() {
        pasteStack.removeAll()
    }

    /// Whether accessibility permission alert is currently showing (prevents duplicates)
    private var isShowingPermissionAlert = false

    private func simulatePaste() {
        guard AXIsProcessTrusted() else {
            logger.error("Accessibility permission not granted — paste blocked")
            guard !isShowingPermissionAlert else { return }
            isShowingPermissionAlert = true
            // Dispatch to escape the async Task context — runModal() needs its own run loop
            DispatchQueue.main.async { [weak self] in
                self?.showAccessibilityAlert()
                self?.isShowingPermissionAlert = false
            }
            return
        }

        guard let source = CGEventSource(stateID: .hidSystemState) else {
            logger.error("Failed to create CGEventSource for paste simulation")
            return
        }

        guard let keyDown = CGEvent(keyboardEventSource: source, virtualKey: 0x09, keyDown: true),
              let keyUp = CGEvent(keyboardEventSource: source, virtualKey: 0x09, keyDown: false)
        else {
            logger.error("Failed to create CGEvent for paste simulation")
            return
        }

        keyDown.flags = .maskCommand
        keyUp.flags = .maskCommand

        keyDown.post(tap: .cghidEventTap)
        keyUp.post(tap: .cghidEventTap)
    }

    /// Show a standalone NSAlert for accessibility permission — works even when the panel isn't visible
    /// (e.g., paste-as-plain-text, paste-from-stack, quick-paste hotkeys)
    private func showAccessibilityAlert() {
        let alert = NSAlert()
        alert.messageText = "Accessibility Permission Required"
        alert.informativeText = "SaneClip needs Accessibility permission to paste into other apps.\n\nGo to System Settings > Privacy & Security > Accessibility and enable SaneClip."
        alert.addButton(withTitle: "Open System Settings")
        alert.addButton(withTitle: "Cancel")
        alert.alertStyle = .warning

        if alert.runModal() == .alertFirstButtonReturn {
            if let url = URL(string: "x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility") {
                NSWorkspace.shared.open(url)
            }
        }
    }

    func delete(item: ClipboardItem) {
        history.removeAll { $0.id == item.id }
        pinnedItems.removeAll { $0.id == item.id }
        saveHistory()

        #if ENABLE_SYNC
            SyncCoordinator.shared.queueDeleteForSync(itemID: item.id)
        #endif
    }

    // MARK: - Sync Support

    #if ENABLE_SYNC
        /// Insert an item received from iCloud sync (no re-sync trigger)
        func insertSyncedItem(_ item: ClipboardItem) {
            // Don't add duplicates
            guard !history.contains(where: { $0.id == item.id }) else { return }
            history.insert(item, at: 0)

            // Trim to max size
            if history.count > maxHistorySize {
                history = Array(history.prefix(maxHistorySize))
            }

            saveHistory()
            logger.debug("Inserted synced item: \(item.id)")
        }

        /// Delete an item received from iCloud sync (no re-sync trigger)
        func deleteSyncedItem(_ itemID: UUID) {
            history.removeAll { $0.id == itemID }
            pinnedItems.removeAll { $0.id == itemID }
            saveHistory()
            logger.debug("Deleted synced item: \(itemID)")
        }
    #endif

    func clearHistory() {
        history.removeAll()
        saveHistory()
    }

    func pasteItemAt(index: Int) {
        guard index < history.count else { return }
        paste(item: history[index])
    }

    func togglePin(item: ClipboardItem) {
        if pinnedItems.contains(where: { $0.id == item.id }) {
            pinnedItems.removeAll { $0.id == item.id }
        } else {
            pinnedItems.insert(item, at: 0)
        }
        saveHistory()
    }

    /// Copy item to clipboard without triggering paste (Cmd+V)
    func copyWithoutPaste(item: ClipboardItem) {
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()

        switch item.content {
        case let .text(string):
            pasteboard.setString(string, forType: .string)
        case let .image(image):
            if let tiffData = image.tiffRepresentation {
                pasteboard.setData(tiffData, forType: .tiff)
            }
        }

        if SettingsModel.shared.playSounds {
            NSSound(named: .init("Pop"))?.play()
        }

        logger.debug("Copied item to clipboard (no paste)")
    }

    /// Update an item's text content (for edit functionality)
    func updateItemContent(id: UUID, newContent: String) {
        guard !newContent.isEmpty else { return }

        if let index = history.firstIndex(where: { $0.id == id }) {
            var updatedItem = history[index]
            updatedItem = ClipboardItem(
                id: updatedItem.id,
                content: .text(newContent),
                timestamp: updatedItem.timestamp,
                sourceAppBundleID: updatedItem.sourceAppBundleID,
                sourceAppName: updatedItem.sourceAppName,
                pasteCount: updatedItem.pasteCount
            )
            history[index] = updatedItem

            // Also update in pinnedItems if present
            if let pinnedIndex = pinnedItems.firstIndex(where: { $0.id == id }) {
                pinnedItems[pinnedIndex] = updatedItem
            }

            saveHistory()
            logger.debug("Updated content for item \(id)")
        }
    }

    func isPinned(_ item: ClipboardItem) -> Bool {
        pinnedItems.contains { $0.id == item.id }
    }

    /// Reorder pinned items via drag and drop
    func movePinnedItems(from source: IndexSet, to destination: Int) {
        pinnedItems.move(fromOffsets: source, toOffset: destination)
        saveHistory()
    }

    /// Export history to JSON data
    func exportHistory() -> Data? {
        let formatter = ISO8601DateFormatter()
        let pinnedIDs = Set(pinnedItems.map(\.id))
        let exportItems = history.compactMap { item -> [String: Any]? in
            var dict: [String: Any] = [
                "id": item.id.uuidString,
                "timestamp": formatter.string(from: item.timestamp),
                "pasteCount": item.pasteCount
            ]

            if case let .text(string) = item.content {
                dict["text"] = string
            } else {
                // Skip images in export
                return nil
            }

            if let bundleID = item.sourceAppBundleID {
                dict["sourceAppBundleID"] = bundleID
            }
            if let appName = item.sourceAppName {
                dict["sourceAppName"] = appName
            }

            dict["isPinned"] = pinnedIDs.contains(item.id)

            return dict
        }

        return try? JSONSerialization.data(withJSONObject: exportItems, options: .prettyPrinted)
    }

    /// Static export function for use from Settings (reads from disk)
    nonisolated static func exportHistoryFromDisk() -> Data? {
        let appSupport = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
        let historyURL = appSupport
            .appendingPathComponent("SaneClip", isDirectory: true)
            .appendingPathComponent("history.json")

        guard FileManager.default.fileExists(atPath: historyURL.path),
              var data = try? Data(contentsOf: historyURL)
        else {
            return nil
        }

        // Auto-detect encrypted vs plaintext
        if HistoryEncryption.isEncrypted(data) {
            guard let decrypted = try? HistoryEncryption.decrypt(data) else { return nil }
            data = decrypted
        }

        guard let items = try? JSONDecoder().decode([SavedClipboardItem].self, from: data) else {
            return nil
        }

        let pinnedIDs = Set(UserDefaults.standard.stringArray(forKey: "pinnedItemIDs") ?? [])
        let formatter = ISO8601DateFormatter()

        let exportItems: [[String: Any]] = items.map { item in
            var dict: [String: Any] = [
                "id": item.id.uuidString,
                "timestamp": formatter.string(from: item.timestamp),
                "text": item.text,
                "pasteCount": item.pasteCount,
                "isPinned": pinnedIDs.contains(item.id.uuidString)
            ]
            if let bundleID = item.sourceAppBundleID {
                dict["sourceAppBundleID"] = bundleID
            }
            if let appName = item.sourceAppName {
                dict["sourceAppName"] = appName
            }
            return dict
        }

        return try? JSONSerialization.data(withJSONObject: exportItems, options: .prettyPrinted)
    }

    // MARK: - Persistence

    private var historyFileURL: URL {
        let appSupport = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
        let appFolder = appSupport.appendingPathComponent("SaneClip", isDirectory: true)
        try? FileManager.default.createDirectory(at: appFolder, withIntermediateDirectories: true)
        return appFolder.appendingPathComponent("history.json")
    }

    func saveHistory() {
        // Only save text items (images are too large)
        let textItems = history.compactMap { item -> SavedClipboardItem? in
            if case let .text(string) = item.content {
                return SavedClipboardItem(
                    id: item.id,
                    text: string,
                    timestamp: item.timestamp,
                    sourceAppBundleID: item.sourceAppBundleID,
                    sourceAppName: item.sourceAppName,
                    pasteCount: item.pasteCount
                )
            }
            return nil
        }

        do {
            var data = try JSONEncoder().encode(textItems)

            // Encrypt if setting is enabled
            if SettingsModel.shared.encryptHistory {
                data = try HistoryEncryption.encrypt(data)
            }

            try data.write(to: historyFileURL, options: [.atomic, .completeFileProtection])

            // Save pinned item IDs separately
            let pinnedIDs = pinnedItems.map(\.id.uuidString)
            UserDefaults.standard.set(pinnedIDs, forKey: "pinnedItemIDs")

            // Update widget data
            updateWidgetData()
        } catch {
            logger.error("Failed to save history: \(error.localizedDescription)")
        }
    }

    // MARK: - Widget Support

    /// Updates widget data in the shared App Group container
    private func updateWidgetData() {
        // Convert history items to widget format
        let recentWidgetItems = history.prefix(10).map { item in
            WidgetClipboardItem(
                id: item.id,
                preview: item.preview,
                timestamp: item.timestamp,
                isPinned: isPinned(item),
                sourceAppName: item.sourceAppName,
                contentType: widgetContentType(for: item)
            )
        }

        // Convert pinned items to widget format
        let pinnedWidgetItems = pinnedItems.map { item in
            WidgetClipboardItem(
                id: item.id,
                preview: item.preview,
                timestamp: item.timestamp,
                isPinned: true,
                sourceAppName: item.sourceAppName,
                contentType: widgetContentType(for: item)
            )
        }

        let container = WidgetDataContainer(
            recentItems: Array(recentWidgetItems),
            pinnedItems: pinnedWidgetItems,
            lastUpdated: Date()
        )

        do {
            try container.save()
            // Tell WidgetKit to reload
            WidgetCenter.shared.reloadAllTimelines()
            logger.debug("Updated widget data with \(recentWidgetItems.count) recent, \(pinnedWidgetItems.count) pinned items")
        } catch {
            logger.warning("Failed to update widget data: \(error.localizedDescription)")
        }
    }

    private func widgetContentType(for item: ClipboardItem) -> WidgetClipboardItem.ContentType {
        switch item.content {
        case .text:
            if item.isURL { return .url }
            if item.isCode { return .code }
            return .text
        case .image:
            return .image
        }
    }

    private func loadHistory() {
        guard FileManager.default.fileExists(atPath: historyFileURL.path) else { return }

        do {
            var data = try Data(contentsOf: historyFileURL)

            // Auto-detect encrypted vs plaintext for seamless migration
            if HistoryEncryption.isEncrypted(data) {
                data = try HistoryEncryption.decrypt(data)
            }

            let items = try JSONDecoder().decode([SavedClipboardItem].self, from: data)
            history = items.map {
                ClipboardItem(
                    id: $0.id,
                    content: .text($0.text),
                    timestamp: $0.timestamp,
                    sourceAppBundleID: $0.sourceAppBundleID,
                    sourceAppName: $0.sourceAppName,
                    pasteCount: $0.pasteCount
                )
            }

            // Restore pinned items from saved IDs
            if let pinnedIDs = UserDefaults.standard.stringArray(forKey: "pinnedItemIDs") {
                let pinnedUUIDs = Set(pinnedIDs.compactMap { UUID(uuidString: $0) })
                pinnedItems = history.filter { pinnedUUIDs.contains($0.id) }
            }
        } catch {
            logger.error("Failed to load history: \(error.localizedDescription)")
        }
    }

    // MARK: - Import History

    enum ImportError: Error, LocalizedError {
        case invalidFormat
        case readFailed
        case decodeFailed

        var errorDescription: String? {
            switch self {
            case .invalidFormat: "Invalid file format"
            case .readFailed: "Could not read file"
            case .decodeFailed: "Could not decode history data"
            }
        }
    }

    /// Import history from a JSON file
    /// - Parameters:
    ///   - url: URL to the JSON file
    ///   - merge: If true, merge with existing history; if false, replace entirely
    /// - Returns: Number of items imported
    @discardableResult
    func importHistory(from url: URL, merge: Bool) throws -> Int {
        // Read file
        guard let data = try? Data(contentsOf: url) else {
            throw ImportError.readFailed
        }

        // Try to decode as SavedClipboardItem array
        guard let items = try? JSONDecoder().decode([SavedClipboardItem].self, from: data) else {
            throw ImportError.decodeFailed
        }

        // Convert to ClipboardItems
        let importedItems = items.map { saved in
            ClipboardItem(
                id: saved.id,
                content: .text(saved.text),
                timestamp: saved.timestamp,
                sourceAppBundleID: saved.sourceAppBundleID,
                sourceAppName: saved.sourceAppName,
                pasteCount: saved.pasteCount
            )
        }

        if merge {
            // Skip items with existing IDs
            let existingIDs = Set(history.map(\.id))
            let newItems = importedItems.filter { !existingIDs.contains($0.id) }
            history.append(contentsOf: newItems)
            // Sort by timestamp, newest first
            history.sort { $0.timestamp > $1.timestamp }
            saveHistory()
            logger.info("Merged \(newItems.count) new items from import")
            return newItems.count
        } else {
            // Replace entire history
            history = importedItems
            pinnedItems = [] // Clear pins since items are new
            saveHistory()
            logger.info("Replaced history with \(importedItems.count) imported items")
            return importedItems.count
        }
    }

    // MARK: - Services Support

    /// Add an item from macOS Services (public wrapper for private addItem)
    func addItemFromService(_ item: ClipboardItem) {
        addItem(item)
    }

    // MARK: - PDF Export

    func exportItemAsPDF(item: ClipboardItem) {
        guard case let .text(text) = item.content else { return }

        let savePanel = NSSavePanel()
        savePanel.allowedContentTypes = [.pdf]
        let firstLine = text.components(separatedBy: .newlines).first ?? "clipboard"
        let cleanName = String(
            firstLine.prefix(50)
                .replacingOccurrences(of: "[^a-zA-Z0-9 _\\-]", with: "", options: .regularExpression)
                .trimmingCharacters(in: .whitespaces)
        )
        savePanel.nameFieldStringValue = (cleanName.isEmpty ? "clipboard" : cleanName) + ".pdf"

        guard savePanel.runModal() == .OK, let url = savePanel.url else { return }

        // PDF dimensions: US Letter
        let pageWidth: CGFloat = 612
        let pageHeight: CGFloat = 792
        let margin: CGFloat = 72
        let textRect = CGRect(x: margin, y: margin, width: pageWidth - 2 * margin, height: pageHeight - 2 * margin)

        let font = CTFontCreateWithName("Menlo" as CFString, 11, nil)
        let paragraphStyle = NSMutableParagraphStyle()
        paragraphStyle.lineSpacing = 4
        let attributes: [NSAttributedString.Key: Any] = [
            .font: font,
            .foregroundColor: NSColor.black,
            .paragraphStyle: paragraphStyle
        ]
        let attributedString = NSAttributedString(string: text, attributes: attributes)
        let framesetter = CTFramesetterCreateWithAttributedString(attributedString)

        var mediaBox = CGRect(x: 0, y: 0, width: pageWidth, height: pageHeight)
        guard let dataConsumer = CGDataConsumer(url: url as CFURL),
              let pdfContext = CGContext(consumer: dataConsumer, mediaBox: &mediaBox, nil)
        else {
            logger.error("Failed to create PDF context")
            return
        }

        var currentIndex = 0
        while currentIndex < attributedString.length {
            pdfContext.beginPDFPage(nil)

            let path = CGPath(rect: textRect, transform: nil)
            let frameRange = CFRange(location: currentIndex, length: 0)
            let frame = CTFramesetterCreateFrame(framesetter, frameRange, path, nil)

            CTFrameDraw(frame, pdfContext)

            let visibleRange = CTFrameGetVisibleStringRange(frame)
            currentIndex += visibleRange.length

            pdfContext.endPDFPage()

            // Safety: break if no progress
            if visibleRange.length == 0 { break }
        }

        pdfContext.closePDF()
        logger.info("Exported clipboard item as PDF to \(url.path)")
    }
}
